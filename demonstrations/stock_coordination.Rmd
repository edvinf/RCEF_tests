---
title: "RCEF stock coordination"
author: "Edvin Fuglebakk"
date: "2024-03-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Format
We will define some preliminary vocabularies for the domain columns:

```{r}
POPULATION_VARIABLES <- c("vesselFlagCounty", "year", "catchCategory", "speciesCode")
ACTIVITY_DOMAIN_VARIABLES <- c("Quarter",	"Month","stockArea",	"area",	"metier6",	"Fleet")
FISH_DOMAIN_VARIABLES <- c("MinAge",	"MaxAge", "Sex")
ESTIMATES_VALUE_VARIABLES <- c("totalNumber", "totalWeightLive", "varTotalNumber", "varTotalWeight")
SAMPLE_DESCRIPTION_VARIABLES <- c("numSamplesLength", "numLngMeas", "numSamplesAge", "sampledCatch")
```


## Aggregate domains

An example of how estimates for activity domains can be aggregated is provided in the following function:

```{r aggregateEstimates}
#' @param RCEF domain definitionns and estimates in the RCEF format.
#' @param desiredDomains table defining desiredDomains. Contain valid domain variables and a column 'activityDomain'
aggregateActivityDomains <- function(RCEF, desiredDomains){

  catch <- data.table::as.data.table(RCEF$CATCH)
  estimates <- data.table::as.data.table(RCEF$ESTIMATES)
  desiredDomains <- data.table::as.data.table(desiredDomains)
  
  #check that the desired domain is defined in terms of valid activity domain variables  
  stopifnot(all(names(desiredDomains) %in% c(ACTIVITY_DOMAIN_VARIABLES, "activityDomain")))
  
  #check that all activity domains in estimates are defined in the catch table
  stopifnot(all(catch$activityDomain %in% catch$activityDomain))
  
  #handle domain variables not in domain definition for estimates
  domainCount <- desiredDomains[,list(NDomains=length(unique(activityDomain))), by=names(desiredDomains)[!(names(desiredDomains) %in% names(catch))]]
  if (ncol(domainCount)>1 & any(domainCount$NDomains>1)){
    stop("Desired domains specify finer resolution that domains estimates are provided for")
  }
  
  # domains encompass all values for domain variables not provided
  desiredDomains <- desiredDomains[,.SD, .SDcol=names(desiredDomains)[names(desiredDomains) %in% names(catch)]]
  if (ncol(desiredDomains) == 1){
    soptifnot(length(unique(desiredDomain$activtyDomain))!=1)
    catch$actvityDomain <- desiredDomain$activtyDomain
  }
  else{
    catch <- merge(catch, desiredDomains, by=names(desiredDomains)[names(desiredDomains)!="activityDomain"], suffixes=c("", ".desired"))
    
    domainCount <- catch[,list(NDomains=unique(activityDomain.desired)), by="activityDomain"]
    if (any(domainCount$Ndomains>1)){
      stop("Some estimated domains are in more than one desired domain.")
    }
  }
  
  estimates$activityDomain.desired <- catch$activityDomain.desired[match(estimates$activityDomain, catch$activityDomain)]
  
  catch$activityDomain <- catch$activityDomain.desired
  catch$activityDomain.desired <- NULL
  
  estimates$activityDomain <- estimates$activityDomain.desired
  estimates$activityDomain.desired <- NULL
  
  aggregated <- NULL
  # iterate over value variables and add
  for (e in names(estimates)){
    if (e %in% ESTIMATES_VALUE_VARIABLES){
      agg <- estimates[,list(agg=sum(get(e))), by=c("fishDomain", "activityDomain")]
      names(agg)[names(agg)=="agg"] <- e
      
      if (is.null(aggregated)){
        aggregated <- agg
      }
      else{
        aggregated <- merge(aggregated, agg)
      }
    }
  }
  # iterate over sample variables and set to NA
  for (e in names(estimates)){
    if (e %in% SAMPLE_DESCRIPTION_VARIABLES){
      aggregated[[e]] <- as.numeric(NA)
    }
  }
  # Compute aggregated mean weight
  agg <- estimates[,list(meanWeightLive = sum(meanWeightLive*totalNumber)/sum(totalNumber), varMeanWeightLive = sum(varMeanWeightLive * (totalNumber/sum(totalNumber))**2)), by=c("fishDomain", "activityDomain")]
  if (is.null(aggregated)){
        aggregated <- agg
  }
  else{
        aggregated <- merge(aggregated, agg)
  }

  RCEF$ESTIMATES <- aggregated
  RCEF$CATCH <- catch
  
  return(RCEF)
}
```

Note that aggregation of means requires different treatment than the simply additive statistics. May consider a more general encoding, where we parameterise variable, and provide Total, Mean, VarTotal, and VarMean for that variable. That was also one of the proposed solutions to handle different length variables (total length, carapax length, fork length, etc).

It is not clear that sample description parameters can be aggregated across activity domains. If PSU is for instance a landing event, some activity domain variables like gear can be covered by the same samples and it is unclear if it can be added. Perhaps these should just be NA as here, be defined as lower bound on sampling, or we need a slightly different format for aggregated results omitting them altogether.

Applying this function to an example file with the estimates reported by age and gear:

```{r}
domainEstimates <- readRDS("../data/estimates_gear_caa.rds")
desiredDomains <- data.table::data.table(activityDomain="all", metier6=c("OTB_SPF_>0_0_0_all","OTM_SPF_>0_0_0_all","PS1_SPF_>0_0_0_all"))
aggregatedEstimates <- aggregateActivityDomains(domainEstimates, desiredDomains)
aggregatedEstimates$ESTIMATES
```
Similarly, grouping only two gears:

```{r}
desiredDomains <- data.table::data.table(activityDomain=c("OT", "OT", "PS"), metier6=c("OTB_SPF_>0_0_0_all","OTM_SPF_>0_0_0_all","PS1_SPF_>0_0_0_all"))
aggregatedEstimates <- aggregateActivityDomains(domainEstimates, desiredDomains)
aggregatedEstimates$ESTIMATES
```


An example of how estimates for fish domains can be aggregated, redefine plusgroup:

```{r}

```


## Imputing domains

